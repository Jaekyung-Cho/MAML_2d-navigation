import numpy as np
import gym
import random

from gym import spaces
from gym.utils import seeding
from gym.envs.classic_control import rendering


class Navigation2DEnv(gym.Env):
    """2D navigation problems, as described in [1]. The code is adapted from 
    https://github.com/cbfinn/maml_rl/blob/9c8e2ebd741cb0c7b8bf2d040c4caeeb8e06cc95/maml_examples/point_env_randgoal.py

    At each time step, the 2D agent takes an action (its velocity, clipped in
    [-0.1, 0.1]), and receives a penalty equal to its L2 distance to the goal 
    position (ie. the reward is `-distance`). The 2D navigation tasks are 
    generated by sampling goal positions from the uniform distribution 
    on [-0.5, 0.5]^2.

    [1] Chelsea Finn, Pieter Abbeel, Sergey Levine, "Model-Agnostic 
        Meta-Learning for Fast Adaptation of Deep Networks", 2017 
        (https://arxiv.org/abs/1703.03400)
    """
    def __init__(self, task={}, low=-0.5, high=0.5):
        super(Navigation2DEnv, self).__init__()
        self.low = low
        self.high = high

        self.observation_space = spaces.Box(low=-np.inf, high=np.inf,
            shape=(2,), dtype=np.float32)
        self.action_space = spaces.Box(low=-0.1, high=0.1,
            shape=(2,), dtype=np.float32)

        self._task = task
        self._goal = task.get('goal', np.zeros(2, dtype=np.float32))
        self._state = np.zeros(2, dtype=np.float32)
        self.seed()

        self._viewer = None
        self.label = None
        self.pre_state = None

    def seed(self, seed=None):
        self.np_random, seed = seeding.np_random(seed)
        return [seed]

    def sample_tasks(self, num_tasks):
        goals = self.np_random.uniform(self.low, self.high, size=(num_tasks, 2))
        # while np.any(goals < 0.02):
        #     goals = np.where(goals >= 0.02, goals, self.np_random.uniform(self.low, self.high, size=(num_tasks, 2)))
        tasks = [{'goal': goal} for goal in goals]
        return tasks
    
    def eval_sample_tasks(self, num_tasks):
        goals = self.np_random.uniform(2*self.low, 2*self.high, size=(num_tasks, 2))
        tasks = [{'goal': goal} for goal in goals]
        return tasks

    def reset_task(self, task=None):
        if not task==None:
            self._task = task
        self._goal = self._task['goal']

    def reset(self, task=None):
        self._state = np.zeros(2, dtype=np.float32)
        if task == None:
            self._task = self.sample_tasks(1)[0]
            self._goal = self._task['goal']
        elif task =='soft':
            pass # reset task
        else:
            self._task = task
            self._goal = task['goal']

        self._viewer = None # viewer delete
        self.pre_state = None

        return self._state

    def step(self, action):
        action = np.clip(action, -0.1, 0.1)
        assert self.action_space.contains(action)
        self._state = self._state + action

        x = self._state[0] - self._goal[0]
        y = self._state[1] - self._goal[1]
        reward = -np.sqrt(x ** 2 + y ** 2)
        done = ((np.abs(x) < 0.01) and (np.abs(y) < 0.01))
        # done = False

        return self._state, reward, done, {'task': self._task}

    def render(self, mode='human', text=None):
        """
        scale -10 ~ 10 -> screen_width
        """
        screen_width = 400
        screen_height = 400
        world_width = 4

        scale = screen_width / world_width
        botwidth = 10.0
        botheight = 10.0

        radius = 5.0

        # define viewer
        if self._viewer is None:

            self._viewer = rendering.Viewer(screen_width, screen_height)

            # robot define
            l, r, t, b = -botwidth / 2, botwidth / 2, botheight / 2, -botheight / 2
            bot = rendering.FilledPolygon([(l, b), (l, t), (r, t), (r, b)])
            self.bottrans = rendering.Transform()
            bot.add_attr(self.bottrans)
            bot.set_color(0,0,1.0)
            self._viewer.add_geom(bot)

            # initial state define
            ini = rendering.make_circle(radius)
            self.initrans = rendering.Transform()
            ini.add_attr(self.initrans)
            ini.set_color(0,1.0,0)
            self._viewer.add_geom(ini)
            self.initrans.set_translation(screen_width / 2.0, screen_height / 2.0)

            # goal define
            goal = rendering.make_circle(radius)
            self.goaltrans = rendering.Transform()
            goal.add_attr(self.goaltrans)
            goal.set_color(1.0,0,0)
            self._viewer.add_geom(goal)
            

        if self._state is None:
            return None

        # robot movement
        x = self._state
        botx = x[0] * scale + screen_width / 2.0  
        boty = x[1] * scale + screen_height / 2.0 
        self.bottrans.set_translation(botx, boty)

        # goal movement
        g = self._goal
        goalx = g[0] * scale + screen_width / 2.0  
        goaly = g[1] * scale + screen_height / 2.0  
        self.goaltrans.set_translation(goalx, goaly)

        # text drawing
        if not self.label == None:
            self.label.delete()
        if not text == None:
            try:
                import pyglet
            except ImportError as e:
                raise ImportError("Import error!!")

            class DrawText:
                def __init__(self, label:pyglet.text.Label):
                    self.label=label
                def render(self):
                    self.label.draw()

            def draw_text(text, x, y, font_size=20, color=(128,128,128,255)):
                label = pyglet.text.Label(text, font_size=font_size,
                                        x=x, y=y, anchor_x='left', anchor_y='bottom',
                                        color=[int(c) for c in color])
                label.draw()
                return label

            self.label = draw_text(text, x=20, y=20)
            self._viewer.add_geom(DrawText(self.label))

        # line drawing
        if self.pre_state == None:
            self.pre_state = (screen_height//2, screen_width//2)
        line = rendering.Line(start = self.pre_state, end=(botx, boty))
        self.pre_state = (botx, boty)
        line.set_color(0.5,0.5,0.5)
        self._viewer.add_geom(line)

        return self._viewer.render(return_rgb_array=mode == "rgb_array")


    def render_final(self):
        pass